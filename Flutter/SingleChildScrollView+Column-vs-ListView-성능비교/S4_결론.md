# 결론(이번에 알게 된 것)
- SCSV, ListView, ListView.builder가 어떤식으로 동작하는지 알게됨
- SCSV, ListView, ListView.builder를 어떤 상황에 사용하는것이 좋을지 생각할 수 있었음
- 예상했던것과 달리 스크롤에서는 SCSV, ListView, ListView.builder 모두 효율적이 었음
- SCSV, ListView, ListView.builder중 하나를 선택할 때 가장 중요한 것이 스크롤이 아닌 build 효율성이라는 것을 알게됨
  - 그런 면에서 요소가 10개가 넘지 않는(화면을 넘기지 않는 상황이 많은) 상황에서는 의외로 SCSV가 가장 높은 효율이 나왔음
  - 그러나, 대부분의 환경에서 요소 수가 10개 수준으로 유지되더라도 어쩌다 한번 100개 1000개 요소 수로 늘어날 수 있는 리스트일 경우에는 ListView나 ListView.builder가 더 좋은 선택지일 수 있음
    - 왜냐하면 적은 요소 수에서는 어차피 큰 효율성 차이가 나지 않지만, 요소수가 많아질수록 각 리스트뷰들 간에 효율성 차이가 크게 벌어지기 때문
  - 이러한 이유로, SCSV 공식문서에서도 언급되었던것 처럼 화면의 레이아웃이 넘치는 경우가 생겨서 어쩔 수 없이 스크롤이 필요한 경우에는 SCSV를 쓰고 나머지는 ListView를 고려하는게 좋을듯

# 남은 의문
- 이번 실험에서는 itemExtent는 효율에 아무런 도움을 주지 못했음, 어떤 상황에서 도움을 주는지 궁금함

# 다음에 할 것(선택)
- 없음.


<br /><br /><br /><br />

## AI 리뷰(답변)
### 좋은 결론
- “스크롤 중엔 전부 예산(16.67ms) 내, 선택 기준은 빌드 비용” → ✅ 타당.
- “뷰포트 이하(10개 내외)는 SCSV도 효율적, 많아지면 ListView 계열” → ✅ 데이터와 일치.

### 보완하면 좋은 점
- 결론에서 “가끔 넘치면 SCSV, 그 외엔 ListView”라는 뉘앙스를 더 명확히:
→ 콘텐츠가 보통은 화면에 ‘맞고’ 드물게만 넘칠 때 = SCSV.
→ 평소에 스크롤이 ‘필요한’ 화면(아이템 많음/동적 증감) = ListView/SliverList.
- 스크롤 벤치 표 상단 문구가 “처음 빌드”로 남아 있었던 부분은 **“20초 스크롤 중 측정”**으로 통일 추천.
- 60Hz에서는 모두 여유지만 **120Hz(8.33ms)**에선 p95/99가 임계 근처일 수 있음 → 결론에 한 줄 단서 추가 권장.

### itemExtent는 언제 체감 효과?
- 고정 높이 + 무거운 셀(텍스트 측정/레이아웃 비용 큼) + 긴 리스트: 스크롤 오프셋 계산을 상수화해 레이아웃 계산 감소.
- 가변 높이 섞임은 효과↓ → 이땐 prototypeItem이 대안.
- 경계 스파이크가 보일 때 cacheExtent 튜닝과 함께 쓰면 p95/99 안정화에 도움.

### 한 줄 가이드
정적·짧은 콘텐츠 = SCSV, 동적·긴 리스트 = ListView.builder(+고정 높이면 itemExtent/혹은 prototypeItem), 최종 선택은 초기 빌드 비용 + p95 안정성 + 메모리로 결정.
