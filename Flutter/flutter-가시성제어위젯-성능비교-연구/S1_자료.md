# 참고한 것들(형식 자유)
- 출처/링크: [Offstage 공식문서] https://api.flutter.dev/flutter/widgets/Offstage-class.html 
  - 메모
     - 해당 사이트 글에 따르면 Offstage는 그려지지 않으면(offstage: true)  paint 하지 않고, 부모의 공간도 점유하지 않는다. 하지만 여전히 위젯 트리에는 존재하며 레이아웃이 되어 있다.
이 말의 의미는 보이지 않는 상태일 경우에도 본인과 자식들의 상태를 유지하고 있어서 re-layout 과정이나 re-build 과정에서 비용이 들어가지만 부모 위젯에게 전달할 때만 size = 0 으로 전달한다는 의미.
즉, 보이지 않아도 여전히 살아있는것처럼 행동하고 (paint 비용만 들지 않는다.)
     - 다른 부분에서 애니메이션이 표시되는 여부에 관계없이 배터리와 CPU를 사용한다는 말이 있는데, 이 부분도 위에서 설명한듯이 상태를 유지한다는 개념에서 바라보면 이해가 감.
     - 추측하자면, 이러한 방식은 화면에 보이지 않는 상태일때는 효율적이지 않지만 보이지 않다가 갑자기 보여줘야 할 때에는 비용이 상대적으로 적게 들 것으로 예상됨(기존에 가지고 있던 상태를 가지고 paint만 해주면 되기 때문에)

- 출처/링크: [Opacity 공식문서] https://api.flutter.dev/flutter/widgets/Opacity-class.html
  - 메모
     - 해당 사이트 글에 따르면 Opacity는 opacity가 0.0 또는 1.0 이 아닌 모든 경우에 투명도 작업을 위해 자식 요소들을 중간 버퍼에 페인팅 해야하는 과정을 거친다고 함
그리고 0.0 일 경우에는 아무런 paint 작업을 아예 하지 않으며 1.0 일 경우에는 paint 작업은 하지만 중간 버퍼에 자식 요소들을 페인팅 하는 과정은 생략한다고 함
추가로, opacity가 0일 경우에도 히트테스트는 동작하며, 이는 사용자에게 아무것도 보이지 않는 영역에 터치 이벤트가 발생할 수 있어서 조심하는것이 좋다는 내용이 있고, Opacity 하위에 애니메이션을 넣는것은 비효율적이고 만약 필요하다면 AnimatedOpacity를 사용하는것을 추천함
     - 0.0 인 상태에서도 여전히 페인팅만 하지 않는다고 나와있으니 Offstage와 마찬가지로 상태를 유지하고 있을것으로 추측됨. 그러므로, 보이지 않는 상태로 자주 둬야 하는 경우 비효율적일 것으로 예상됨
     - 추측하건데, 위에서 말 한 것처럼 Offstage와 비슷하게 보이지 않는 상황에서도 상태와 크기를 유지하고 있으므로 보이지 않다가 갑자기 보여줘야 할 때에는 비용이 상대적으로 적게 들 것으로 예상됨

- 출처/링크: [Visibility 공식문서] https://api.flutter.dev/flutter/widgets/Visibility-class.html
  - 메모
     - 해당 사이트 글에 따르면 Visibility 위젯은 하위 트리에 포함할지 하지 않을지 여부를 제어하며, visible: false 일 경우 하위 트리에 위젯을 대체 자식으로 변환한다고 나와 있음. (일반적으로 크기가 0인 상자)
이 부분은 Visibility도 내부적으로 if else 문을 사용하고 있는것이 아닐지 추측하게 만듦
     - Visibility의 visible 방식을 쓴다면, visible: false 일 경우 아예 하위 위젯에서 사라짐으로서 보이지 않는 상태에서의 효율성은 높을것으로 기대됨(상위 위젯이 rebuild될 때 위젯 트리가 없는 것으로 처리되기 때문)
     - maintain* 키워드를 true 함으로써 크기든, 히스테스팅이든 여러가지 상태를 유지할 수 있지만 유지한다는것 자체로 SizedBox.shrink가 아닌 다른것으로 대체되는것이고 그것이 자식 위젯의 상태를 그대로 유지한다는 면에서 보면 효율성이 Opacity나 Offstage를 사용하는것과 별반 다르지 않을것으로 추측됨 (순수한 visibility를 활용하려면 maintain을 쓰지말고 차라리 다른 위젯을 활용하는게 좋을것 같고 다른 가시성위젯들의 효과를 섞어야 하는 경우에만 visibility와 maintain 옵션을 섞어서 활용하는것이 좋아보임)
     - 기본적인 visibility만 활용했을 경우(maintain* 옵션 없이) 화면에 보이지 않는 경우에 효율은 최상일것으로 예상됨
     - 그러나, 다시 보여줘야 하는 경우에는 없었던 위젯을 다시 새롭게 만들어야 함으로 가시성이 자주 토글되는 위젯에서는 효율성이 그다지 좋지 않을것으로 보임

- 출처/링크: [if else] 없음
  - 메모
     - 간단하게 if else 문으로 보이거나 보이지 않게 하는것은 순수하게 사용된 visibility와 거의 동일한 효과를 보여줄 것으로 기대됨
  

# 얻은 핵심
- offstage나 opacity는(0.0, 1.0 상태만 활용할 경우) 보이지 않는 상태에서도 자식 위젯의 상태를 그대로 유지함 차이가 있다면 히트 테스팅이 되는지 안되는지 여부와와 size가 0인지 아닌지 정도
그 말은, 자주 가시성이 토글되는 위젯일 경우 offstage, opacity가 순수한 visibility나 if-else 제어보다 효율성이 좋고, 그 중에서도 offstage가 조금 더 우세할 것이라고 기대해 볼 수 있음
- 반대로 순수한 visibility나 if-else 제어일 경우 보이지 않는 상태를 오래 유지해야 하고 부모 위젯이 자주 리빌드 되는 경우에 상태 자체가 없으므로 opacity나 offstage보다 효율이 더 좋다고 볼 수 있음
또한, 자주 토글되는 화면이라고 하더라도 거대한 애니메이션이 있는 경우 offstage, opacity는 보이지 않아도 cpu에서 애니메이션 연산을 계속 하고 있으므로 TickerMode를 사용하지 않을 경우에는 visibility나 if-else 활용이 효율이 더 좋을 수 있음

# 떠오른 생각
- 단순하게 비교만 하면 **얻은 핵심** 부분 처럼 명료하지만, 중요한거은 평균적으로 좋은 성능을 내는 것이 무엇인가임 예를 들어서 visibility나 if-else 가 보이지 않는 상태에서 아무리 월등한 성능을 내고 있다고 해도, 가시성 토글에서 정크를 일으킬 만큼 효율이 나쁘다면, 그것은 좋은 것이 아님(반대도 마찬가지) 
그런 면에서 화면 토글이 사용자에 의해 발생하거나 1회 이상 발생해야 하는 상황에서는 아무리 if-else나 visibile이 안보이는 상황에서 좋다고 해도, 평균적으로 기복없는 성능을 위해서는 offstage나 opacity 그 중에서도 offstage를 활용하는게 좋지 않을까 싶음, 반대로 첫 화면 진입에서 가시성이 결정되거나 가시성 변경이 딱 한번 또는 한번도 일어나지 않는 화면에서는 if-else 나 visibility 활용이 좋다고 봄

# 아직 모르는 점
- **떠오른 생각** 에서 말 한 것은 결국 뇌피셜일 뿐이며 해보지 않으면 모름

<br /><br /><br /><br />
---
<br /><br /><br /><br />

## AI 리뷰(답변)

### 잘 분석/조사한 부분
- 세 위젯의 핵심 축을 레이아웃·페인트·프레임 안정성 관점으로 분해해 비교한 점이 좋습니다.
- Offstage(offstage:true)가 레이아웃은 수행하되 페인트/히트테스트는 제외되고 부모엔 size=0을 보고한다는 요지, 그리고 애니메이션은 자동으로 멈지 않는다는 주지까지 정확합니다.
- Opacity가 0↔1 사이에서 중간 버퍼(레이어)로 인해 페인트 비용이 커진다는 지적과, 0.0에서도 히트테스트가 남는다는 리스크를 짚은 건 실전적인 포인트입니다.
- Visibility(visible:false)의 대체 위젯 치환과 maintain* 옵션이 비용을 되돌린다는 설명도 적절합니다.
- “오래 숨김은 제거, 자주 토글은 유지(상태 보존)”라는 결론은 주제에 부합하고 방향이 올바릅니다.

### 틀린 부분/과한 일반화
- “자주 토글이면 Offstage가 Opacity보다 우세”라는 단정은 조건부입니다.
  - 레이아웃 기하(공간)를 유지해야 하는 경우엔 Opacity(0.0)가 상위·형제 레이아웃 변동을 막아 프레임 안정성이 더 나을 수 있습니다. 반대로 공간을 접어야 한다면 Offstage가 맞습니다.
- “Visibility의 maintain*을 쓰면 Offstage/Opacity와 별반 다르지 않다”는 평가는 일부 빗나갑니다.
  - Visibility(visible:false, maintainState:true)는 내부적으로 Offstage + TickerMode 조합이 되어 애니메이션이 기본 멈춤(maintainAnimation=false 기본값) 입니다. 같은 “유지” 계열이라도 CPU/배터리 지속 비용에서 Offstage 단독보다 유리할 수 있습니다.

### 놓친 부분(주제 범위 내 보강)
- 지속 레이아웃 비용 vs 토글 스파이크:
  - Offstage/maintainState는 숨김 동안에도 레이아웃 비용이 반복적으로 들 수 있습니다(상위가 레이아웃을 요청할 때마다 전파).
  - 제거(Visibility false/if-else)는 숨김 동안 비용 최소지만 재부착 순간 전체 빌드·레이아웃이 한 프레임에 몰릴 수 있습니다. ~~**글에서는 암시만 되어 있어, 이 교환관계를 한 문장으로 더 명료히 박아두면 좋습니다.**~~
- 프레임 안정성의 또 다른 축—레이아웃 변동성: Offstage는 부모에 0 크기를 보고해 형제 배치가 재계산됩니다. 반면 Opacity(0.0)은 공간을 유지해 레이아웃 재흐름을 피함—토글 순간의 안정성에 직접적입니다

